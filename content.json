{"meta":{"title":"柳英伟博客","subtitle":"柳英伟博客","description":"柳英伟博客","author":"柳英伟","url":"http://marvin9002.github.com"},"pages":[{"title":"友情链接","date":"2018-03-31T14:35:16.799Z","updated":"2018-03-31T14:35:16.799Z","comments":true,"path":"links/index.html","permalink":"http://marvin9002.github.com/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-03-31T14:35:16.798Z","updated":"2018-03-31T14:35:16.798Z","comments":false,"path":"books/index.html","permalink":"http://marvin9002.github.com/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-03-31T14:35:16.799Z","updated":"2018-03-31T14:35:16.799Z","comments":false,"path":"repository/index.html","permalink":"http://marvin9002.github.com/repository/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-03-31T11:02:45.000Z","updated":"2018-04-11T12:24:08.419Z","comments":true,"path":"about/index.html","permalink":"http://marvin9002.github.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-03-31T16:03:24.812Z","updated":"2018-03-31T16:03:24.811Z","comments":false,"path":"categories/index.html","permalink":"http://marvin9002.github.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-03-31T16:03:47.554Z","updated":"2018-03-31T16:03:47.552Z","comments":false,"path":"tags/index.html","permalink":"http://marvin9002.github.com/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-31T12:10:21.000Z","updated":"2018-03-31T12:10:21.515Z","comments":true,"path":"tags/index-1.html","permalink":"http://marvin9002.github.com/tags/index-1.html","excerpt":"","text":""}],"posts":[{"title":"数据库系统原理","slug":"数据库系统原理","date":"2018-04-11T06:25:04.000Z","updated":"2018-04-11T06:31:08.743Z","comments":true,"path":"2018/04/11/数据库系统原理/","link":"","permalink":"http://marvin9002.github.com/2018/04/11/数据库系统原理/","excerpt":"","text":"一、事务概念 事务指的是满足 ACID 特性的一系列操作。在数据库中，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 四大特性 1. 原子性（Atomicity）事务被视为不可分割的最小单元，要么全部提交成功，要么全部失败回滚。 2. 一致性（Consistency）事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。 3. 隔离性（Isolation）一个事务所做的修改在最终提交以前，对其它事务是不可见的。 4. 持久性（Durability）一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来保证持久性。 二、并发一致性问题在并发环境下，一个事务如果受到另一个事务的影响，那么事务操作就无法满足一致性条件。 问题1. 丢失修改T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。 2. 读脏数据T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。 3. 不可重复读T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和和第一次读取的结果不同。 4. 幻影读T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。 解决方法产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。 在没有并发的情况下，事务以串行的方式执行，互不干扰，因此可以保证隔离性。在并发的情况下，如果能通过并发控制，让事务的执行结果和某一个串行执行的结果相同，就认为事务的执行结果满足隔离性要求，也就是说是正确的。把这种事务执行方式称为 可串行化调度 。 并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。 三、封锁封锁粒度 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 但是加锁需要消耗资源，锁的各种操作，包括获取锁，检查锁是否已经解除、释放锁，都会增加系统开销。因此封锁粒度越小，系统开销就越大。需要在锁开销以及数据安全性之间做一个权衡。 MySQL 中提供了两种封锁粒度：行级锁以及表级锁。 封锁类型1. 排它锁与共享锁 排它锁（Exclusive），简写为 X 锁，又称写锁。 共享锁（Shared），简写为 S 锁，又称读锁。 有以下两个规定： 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 锁的兼容关系如下： - X S X No No S No Yes 2. 意向锁意向锁（Intention Locks）可以支持多粒度封锁。它本身是一个表锁，通过在原来的 X/S 锁之上引入了 IX/IS，用来表示一个事务想要在某个数据行上加 X 锁或 S 锁。 有以下两个规定： 一个事务在获得某个数据行对象的 S 锁之前，必须先获得 IS 锁或者更强的锁； 一个事务在获得某个数据行对象的 X 锁之前，必须先获得 IX 锁。 各种锁的兼容关系如下： - X IX S IS X No No No No IX No Yes No Yes S No No Yes Yes IS No Yes Yes Yes 封锁协议1. 三级封锁协议一级封锁协议 事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。 可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么一个事务的修改就不会被覆盖。 T1 T1 lock-x(A) read A=20 lock-x(A) wait write A=19 commit unlock-x(A) obtain read A=19 write A=21 commit unlock-x(A) 二级封锁协议 在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。 T1 T1 lock-x(A) read A=20 write A=19 lock-s(A) wait rollback A=20 unlock-x(A) obtain read A=20 commit unlock-s(A) 三级封锁协议 在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。 T1 T1 lock-s(A) read A=20 lock-x(A) wait read A=20 commit unlock-s(A) obtain read A=20 write A=19 commit unlock-X(A) 2. 两段锁协议加锁和解锁分为两个阶段进行，事务 T 对数据 A 进行读或者写操作之前，必须先获得对 A 的封锁，并且在释放一个封锁之后，T 不能再获得任何的其它锁。 事务遵循两段锁协议是保证并发操作可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。 1lock-x(A)...lock-s(B)...lock-s(c)...unlock(A)...unlock(C)...unlock(B) 但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。 1lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(c)...unlock(C)... 四、隔离级别 1. 未提交读（READ UNCOMMITTED） 事务中的修改，即使没有提交，对其它事务也是可见的。 2. 提交读（READ COMMITTED） 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 3. 可重复读（REPEATABLE READ） 保证在同一个事务中多次读取同样数据的结果是一样的。 4. 可串行化（SERIALIXABLE） 强制事务串行执行。 四个隔离级别的对比 隔离级别 脏读 不可重复读 幻影读 未提交读 YES YES YES 提交读 NO YES YES 可重复读 NO NO YES 可串行化 NO NO NO 五、多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC；可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。 版本号 系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。 事务版本号：事务开始时的系统版本号。 InooDB 的 MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号： 创建版本号：指示创建一个数据行的快照时的系统版本号； 删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。 Undo 日志InnoDB 的 MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。 实现过程以下过程针对可重复读隔离级别。 1. SELECT该操作必须保证多个事务读取到同一个数据行的快照，这个快照是最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。 当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。 把没对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。 除了上面的要求，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。 2. INSERT将系统版本号作为数据行快照的创建版本号。 3. DELETE将系统版本号作为数据行快照的删除版本号。 4. UPDATE将系统版本号作为更新后的数据行快照的创建版本号，同时将系统版本号作为更新前的数据行快照的删除版本号。可以理解为先执行 DELETE 后执行 INSERT。 快照读与当前读1. 快照读读取快照中的数据。 引入快照读的目的主要是为了免去加锁操作带来的性能开销，但是当前读需要加锁。 1select * from table ....; 2. 当前读读取最新的数据。 需要加锁，以下第一个语句加 S 锁，其它都加 X 锁。 12345select * from table where ? lock in share mode;select * from table where ? for update;insert;update ;delete; 六、Next-Key LocksNext-Key Locks 也是 MySQL 的 InnoDB 存储引擎的一种锁实现。MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读隔离级别下，MVCC + Next-Key Locks，就可以防止幻读的出现。 Record Locks锁定的对象是索引，而不是数据。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚集索引，因此 Record Locks 依然可以使用。 Grap Locks锁定一个范围内的索引，例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。 1SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE; Next-Key Locks它是 Record Locks 和 Gap Locks 的结合。在 user 中有以下记录： 12345678| id | last_name | first_name | age ||------|-------------|--------------|-------|| 4 | stark | tony | 21 || 1 | tom | hiddleston | 30 || 3 | morgan | freeman | 40 || 5 | jeff | dean | 50 || 2 | donald | trump | 80 |+------|-------------|--------------|-------+ 那么就需要锁定以下范围： 123456(-∞, 21](21, 30](30, 40](40, 50](50, 80](80, ∞) 七、关系数据库设计理论函数依赖记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。 如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。 对于 W-&gt;A，如果能找到 W 的真子集 W’，使得 W’-&gt; A，那么 W-&gt;A 就是部分函数依赖，否则就是完全函数依赖； 异常以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。 Sno Sname Sdept Mname Cname Grade 1 学生-1 学院-1 院长-1 课程-1 90 2 学生-2 学院-2 院长-2 课程-2 80 2 学生-2 学院-2 院长-2 课程-1 100 不符合范式的关系，会产生很多异常，主要有以下四种异常： 冗余数据，例如学生-2 出现了两次。 修改异常，修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。 删除异常，删除一个信息，那么也会丢失其它信息。例如如果删除了课程-1，需要删除第一行和第三行，那么学生-1 的信息就会丢失。 插入异常，例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。 范式范式理论是为了解决以上提到四种异常。高级别范式的依赖于低级别的范式。 1. 第一范式 (1NF)属性不可分； 2. 第二范式 (2NF)每个非主属性完全函数依赖于键码。 可以通过分解来满足。 分解前 Sno Sname Sdept Mname Cname Grade 1 学生-1 学院-1 院长-1 课程-1 90 2 学生-2 学院-2 院长-2 课程-2 80 2 学生-2 学院-2 院长-2 课程-1 100 以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖： Sno, Cname -&gt; Sname, Sdept, Mname Son -&gt; Sname, Sdept Sdept -&gt; Mname Sno -&gt; Manme Sno, Cname-&gt; Grade Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。 Sname, Sdept 和 Manme 都函数依赖于 Sno，而部分依赖于键码。当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。 分解后 关系-1 Sno Sname Sdept Mname 1 学生-1 学院-1 院长-1 2 学生-2 学院-2 院长-2 有以下函数依赖： Sno -&gt; Sname, Sdept, Mname Sdept -&gt; Mname 关系-2 Sno Cname Grade 1 课程-1 90 2 课程-2 80 2 课程-1 100 有以下函数依赖： Sno, Cname -&gt; Grade 3. 第三范式 (3NF)非主属性不传递依赖于键码。 上面的关系-1 中存在以下传递依赖：Sno -&gt; Sdept -&gt; Mname，可以进行以下分解： 关系-11 Sno Sname Sdept 1 学生-1 学院-1 2 学生-2 学院-2 关系-12 Sdept Mname 学院-1 院长-1 学院-2 院长-2 4. BC 范式（BCNF）所有属性不传递依赖于键码。 关系 STC(Sname, Tname, Cname, Grade) 的四个属性分别为学生姓名、教师姓名、课程名和成绩，它的键码为 (Sname, Cname, Tname)，有以下函数依赖： Sname, Cname -&gt; Tname Sname, Cname -&gt; Grade Sname, Tname -&gt; Cname Sname, Tname -&gt; Grade Tname -&gt; Cname 存在着以下函数传递依赖： Sname -&gt; Tname -&gt; Cname 可以分解成 SC(Sname, Cname, Grade) 和 ST(Sname, Tname)，对于 ST，属性之间是多对多关系，无函数依赖。 八、数据库系统概述基本术语1. 数据模型由数据结构、数据操作和完整性三个要素组成。 2. 数据库系统数据库系统包含所有与数据库相关的内容，包括数据库、数据库管理系统、应用程序以及数据库管理员和用户，还包括相关的硬件和软件。 数据库的三层模式和两层映像 外模式：局部逻辑结构 模式：全局逻辑结构 内模式：物理结构 1. 外模式又称用户模式，是用户和数据库系统的接口，特定的用户只能访问数据库系统提供给他的外模式中的数据。例如不同的用户创建了不同数据库，那么一个用户只能访问他有权限访问的数据库。 一个数据库可以有多个外模式，一个用户只能有一个外模式，但是一个外模式可以给多个用户使用。 2. 模式可以分为概念模式和逻辑模式，概念模式可以用概念-关系来描述；逻辑模式使用特定的数据模式（比如关系模型）来描述数据的逻辑结构，这种逻辑结构包括数据的组成、数据项的名称、类型、取值范围。不仅如此，逻辑模式还要描述数据之间的关系、数据的完整性与安全性要求。 3. 内模式又称为存储模式，描述记录的存储方式，例如索引的组织方式、数据是否压缩以及是否加密等等。 4. 外模式/模式映像把外模式的局部逻辑结构和模式的全局逻辑结构联系起来。该映像可以保证数据和应用程序的逻辑独立性。 5. 模式/内模式映像把模式的全局逻辑结构和内模式的物理结构联系起来，该映像可以保证数据和应用程序的物理独立性。 九、关系数据库建模ER 图Entity-Relationship，有三个组成部分：实体、属性、联系。 1. 实体的三种联系联系包含一对一，一对多，多对多三种。 如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；如果是一对一，画两个带箭头的线段；如果是多对多，画两个不带箭头的线段。下图的 Course 和 Student 是一对多的关系。 2. 表示出现多次的关系一个实体在联系出现几次，就要用几条线连接。下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。 3. 联系的多向性虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。 一般只使用二元联系，可以把多元关系转换为二元关系。 4. 表示子类用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。 十、约束1. 键码用于唯一表示一个实体。 键码可以由多个属性构成，每个构成键码的属性称为码。 2. 单值约束某个属性的值是唯一的。 3. 引用完整性约束一个实体的属性引用的值在另一个实体的某个属性中存在。 4. 域约束某个属性的值在特定范围之内。 5. 一般约束比如大小约束，数量约束。 参考资料 史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006. 施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013. The InnoDB Storage Engine Transaction isolation levels Concurrency Control The Nightmare of Locking, Blocking and Isolation Levels! 三级模式与两级映像 Database Normalization and Normal Forms with an Example The basics of the InnoDB undo logging and history system MySQL locking for the busy web developer 浅入浅出 MySQL 和 InnoDB fd945daf-4a6c-4f20-b9c2-5390f5955ce5.jpg if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"数据库","slug":"数据库","permalink":"http://marvin9002.github.com/categories/数据库/"}],"tags":[{"name":"存储引擎","slug":"存储引擎","permalink":"http://marvin9002.github.com/tags/存储引擎/"},{"name":"数据类型","slug":"数据类型","permalink":"http://marvin9002.github.com/tags/数据类型/"},{"name":"索引","slug":"索引","permalink":"http://marvin9002.github.com/tags/索引/"},{"name":"四大特效","slug":"四大特效","permalink":"http://marvin9002.github.com/tags/四大特效/"}]},{"title":"Git学习指南","slug":"Git学习指南","date":"2018-04-10T11:25:50.000Z","updated":"2018-04-10T11:37:32.685Z","comments":true,"path":"2018/04/10/Git学习指南/","link":"","permalink":"http://marvin9002.github.com/2018/04/10/Git学习指南/","excerpt":"","text":"学习资料 Git - 简明指南 图解 Git 廖雪峰 : Git 教程 Learn Git Branching 集中式与分布式Git 属于分布式版本控制系统，而 SVN 属于集中式。 集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码。 集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。 集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件的会慢的无法让人忍受。而分布式版本控制不需要连网就能工作。 分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码。 Git 的中心服务器Git 的中心服务器用来交换每个用户的修改。没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。Github 就是一种 Git 中心服务器。 Git 工作流 新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。 Git 版本库有一个称为 stage 的暂存区，还有自动创建的 master 分支以及指向分支的 HEAD 指针。 git add files 把文件的修改添加到暂存区 git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了 git reset – files 使用当前分支上的修改覆盖暂缓区，用来撤销最后一次 git add files git checkout – files 使用暂存区的修改覆盖工作目录，用来撤销本地修改 可以跳过暂存区域直接从分支中取出修改或者直接提交修改到分支中 git commit -a 直接把所有文件的修改添加到暂缓区然后执行提交 git checkout HEAD – files 取出最后一次修改，可以用来进行回滚操作 分支实现Git 把每次提交都连成一条时间线。分支使用指针来实现，例如 master 分支指针指向时间线的最后一个节点，也就是最后一次提交。HEAD 指针指向的是当前分支。 新建分支是新建一个指针指向时间线的最后一个节点，并让 HEAD 指针指向新分支表示新分支成为当前分支。 每次提交只会让当前分支向前移动，而其它分支不会移动。 合并分支也只需要改变指针即可。 冲突当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。 Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ，======= ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突。 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Fast forward“快进式合并”（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。 可以在合并时加上 –no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit。 1$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 分支管理策略master 分支应该是非常稳定的，只用来发布新版本； 日常开发在开发分支 dev 上进行。 储藏（Stashing）在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故。 可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈上，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。 123$ git stashSaved working directory and index state \\ &quot;WIP on master: 049d078 added the index file&quot;HEAD is now at 049d078 added the index file (To restore them type &quot;git stash apply&quot;) 该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来。 SSH 传输设置Git 仓库和 Github 中心仓库之间是通过 SSH 加密。 如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key： 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 然后把公钥 id_rsa.pub 的内容复制到 Github “Account settings” 的 SSH Keys 中。 .gitignore 文件忽略以下文件： 操作系统自动生成的文件，比如缩略图； 编译生成的中间文件，比如 Java 编译产生的 .class 文件； 自己的敏感信息，比如存放口令的配置文件。 不需要全部自己编写，可以到 https://github.com/github/gitignore 中进行查询。 Git 命令一览 比较详细的地址：http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"工具","slug":"工具","permalink":"http://marvin9002.github.com/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://marvin9002.github.com/tags/Git/"},{"name":"面试","slug":"面试","permalink":"http://marvin9002.github.com/tags/面试/"},{"name":"工具","slug":"工具","permalink":"http://marvin9002.github.com/tags/工具/"}]},{"title":"MySQL面试知识","slug":"MySql面试知识","date":"2018-04-10T09:55:04.000Z","updated":"2018-04-11T06:25:34.031Z","comments":true,"path":"2018/04/10/MySql面试知识/","link":"","permalink":"http://marvin9002.github.com/2018/04/10/MySql面试知识/","excerpt":"","text":"一、存储引擎InnoDBInnoDB 是 MySQL 默认的事务型存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使用其它存储引擎。 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别，默认级别是可重复读。 表是基于聚簇索引建立的，它对主键的查询性能有很高的提升。 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够自动在内存中创建哈希索引以加速读操作的自适应哈希索引、能够加速插入操作的插入缓冲区等。 通过一些机制和工具支持真正的热备份。 MyISAMMyISAM 提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等。但 MyISAM 不支持事务和行级锁，而且崩溃后无法安全恢复。 只能对整张表加锁，而不是针对行。 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。 可以包含动态或者静态的行。 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。 如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表适合采用 MyISAM 压缩表。 对于只读数据，或者表比较小、可以容忍修复操作，则依然可以继续使用 MyISAM。 MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。 比较 事务：InnoDB 是事务型的。 备份：InnoDB 支持在线热备份。 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。 其它特性：MyISAM 支持全文索引，地理空间索引。 二、数据类型整型TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。 INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。 浮点数FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。 FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。 字符串主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。 VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。 VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。 时间和日期MySQL 提供了两种相似的日期时间类型：DATATIME 和 TIMESTAMP。 1. DATATIME能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。 它与时区无关。 默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATATIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。 2. TIMESTAMP和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。 它和时区有关。 MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。 默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。 应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。 三、索引索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。 索引能够轻易将查询性能提升几个数量级。 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。对于中到大型的表，索引就非常有效。但是对于特大型的表，建立和使用索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 索引分类1. B+Tree 索引 《高性能 MySQL》一书使用 B-Tree 进行描述，其实从技术上来说这种索引是 B+Tree。 B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。 因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。 可以指定多个列作为索引列，多个索引列共同组成键。B+Tree 索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。 除了用于查找，还可以用于排序和分组。 如果不是按照索引列的顺序进行查找，则无法使用索引。 2. 哈希索引基于哈希表实现，优点是查找非常快。 在 MySQL 中只有 Memory 引擎显式支持哈希索引。 InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 限制：哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响并不明显；无法用于分组与排序；只支持精确查找，无法用于部分查找和范围查找；如果哈希冲突很多，查找速度会变得很慢。 3. 空间索引（R-Tree）MyISAM 存储引擎支持空间索引，可以用于地理数据存储。 空间索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。 4. 全文索引MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值。 使用 MATCH AGAINST，而不是普通的 WHERE。 索引的优点 大大减少了服务器需要扫描的数据量； 帮助服务器避免进行排序和创建临时表； 将随机 I/O 变为顺序 I/O。 索引优化1. 独立的列在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 例如下面的查询不能使用 actor_id 列的索引： 1SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 2. 前缀索引对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 对于前缀长度的选取需要根据 索引选择性 来确定：不重复的索引值和记录总数的比值。选择性越高，查询效率也越高。最大值为 1，此时每个记录都有唯一的索引与其对应。 3. 多列索引在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。 12SELECT film_id, actor_ id FROM sakila.film_actorWhERE actor_id = 1 AND film_id = 1; 4. 索引列的顺序让选择性最强的索引列放在前面，例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 1234SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment; 123 staff_id_selectivity: 0.0001customer_id_selectivity: 0.0373 COUNT(*): 16049 5. 聚簇索引 聚簇索引并不是一种索引类型，而是一种数据存储方式。 术语“聚簇”表示数据行和相邻的键值紧密地存储在一起，InnoDB 的聚簇索引的数据行存放在 B+Tree 的叶子页中。 因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。 优点 可以把相关数据保存在一起，减少 I/O 操作； 因为数据保存在 B+Tree 中，因此数据访问更快。 缺点 聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引。 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的。 更新操作代价很高，因为每个被更新的行都会移动到新的位置。 当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间。 如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢。 6. 覆盖索引索引包含所有需要查询的字段的值。 优点 因为索引条目通常远小于数据行的大小，所以若只读取索引，能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若二级索引能够覆盖查询，则无需访问聚簇索引。 B-Tree 和 B+Tree 原理1. B-Tree 为了描述 B-Tree，首先定义一条数据记录为一个二元组 [key, data]，key 为记录的键，data 为数据记录除 key 外的数据。 B-Tree 是满足下列条件的数据结构： 所有叶节点具有相同的深度，也就是说 B-Tree 是平衡的； 一个节点中的 key 从左到右非递减排列； 如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于 keyi 且小于 keyi+1。 在 B-Tree 中按 key 检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的 data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到 null 指针，前者查找成功，后者查找失败。 由于插入删除新的数据记录会破坏 B-Tree 的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持 B-Tree 性质。 2. B+Tree 与 B-Tree 相比，B+Tree 有以下不同点： 每个节点的指针上限为 2d 而不是 2d+1； 内节点不存储 data，只存储 key，叶子节点不存储指针。 3. 带有顺序访问指针的 B+Tree 一般在数据库系统或文件系统中使用的 B+Tree 结构都在经典 B+Tree 基础上进行了优化，在叶子节点增加了顺序访问指针，做这个优化的目的是为了提高区间访问的性能。 4. 为什么使用 B-Tree 和 B+Tree红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用 B-/+Tree 作为索引结构。 页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为 4k），主存和磁盘以页为单位交换数据。 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。B-Tree 中一次检索最多需要 h-1 次 I/O（根节点常驻内存），渐进复杂度为 O(h)=O(logdN)。一般实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3）。而红黑树这种结构，h 明显要深的多。并且于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，效率明显比 B-Tree 差很多。 B+Tree 更适合外存索引，原因和内节点出度 d 有关。由于 B+Tree 内节点去掉了 data 域，因此可以拥有更大的出度，拥有更好的性能。 四、查询性能优化Explain用来分析 SQL 语句，分析结果中比较重要的字段有： select_type : 查询类型，有简单查询、联合查询和子查询 key : 使用的索引 rows : 扫描的行数 减少返回的列慢查询主要是因为访问了过多数据，除了访问过多行之外，也包括访问过多列。 最好不要使用 SELECT * 语句，要根据需要选择查询的列。 减少返回的行最好使用 LIMIT 语句来取出想要的那些行。 还可以建立索引来减少条件语句的全表扫描。例如对于下面的语句，不使用索引的情况下需要进行全表扫描，而使用索引只需要扫描几行记录即可，使用 Explain 语句可以通过观察 rows 字段来看出这种差异。 1SELECT * FROM sakila.film_actor WHERE film_id = 1; 拆分大的 DELETE 或 INSERT 语句如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 1DELEFT FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH); 12345rows_affected = 0do &#123; rows_affected = do_query( \"DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000\")&#125; while rows_affected &gt; 0 五、切分随着时间和业务的发展，数据库中的表会越来越多，并且表中的数据量也会越来越大，那么读写操作的开销也会随着增大。 垂直切分将表按功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立商品数据库 payDB、用户数据库 userDB 等，分别用来存储项目与商品有关的表和与用户有关的表。 水平切分把表中的数据按照某种规则存储到多个结构相同的表中，例如按 id 的散列值、性别等进行划分。 切分的选择如果数据库中的表太多，并且项目各项业务逻辑清晰，那么垂直切分是首选。 如果数据库的表不多，但是单表的数据量很大，应该选择水平切分。 存在的问题1. 事务问题在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。 2. 跨库跨表连接问题在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上。这时，表的连接操作将受到限制，我们无法连接位于不同分库的表，也无法连接分表粒度不同的表，导致原本只需要一次查询就能够完成的业务需要进行多次才能完成。 3. 额外的数据管理负担和数据运算压力最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算。 六、故障转移和故障恢复故障转移也叫做切换，当主库出现故障时就切换到备库，使备库成为主库。故障恢复顾名思义就是从故障中恢复过来，并且保证数据的正确性。 提升备库或切换角色提升一台备库为主库，或者在一个主-主复制结构中调整主动和被动角色。 虚拟 IP 地址和 IP 托管为 MySQL 实例指定一个逻辑 IP 地址，当 MySQL 实例失效时，可以将 IP 地址转移到另一台 MySQL 服务器上。 中间件解决方案通过代理，可以路由流量到可以使用的服务器上。 在应用中处理故障转移将故障转移整合到应用中可能导致应用变得太过笨拙。 参考资料 BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013. How Sharding Works MySQL 索引背后的数据结构及算法原理 20+ 条 MySQL 性能优化的最佳经验 数据库为什么分库分表？mysql的分库分表方案 if (typeof lightGallery !== 'undefined') { var options = { selector: '.gallery-item' }; lightGallery(document.getElementsByClassName('.article-gallery')[0], options); }","categories":[{"name":"数据库","slug":"数据库","permalink":"http://marvin9002.github.com/categories/数据库/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://marvin9002.github.com/tags/面试/"},{"name":"存储引擎","slug":"存储引擎","permalink":"http://marvin9002.github.com/tags/存储引擎/"},{"name":"数据类型","slug":"数据类型","permalink":"http://marvin9002.github.com/tags/数据类型/"},{"name":"时间和日期","slug":"时间和日期","permalink":"http://marvin9002.github.com/tags/时间和日期/"},{"name":"索引","slug":"索引","permalink":"http://marvin9002.github.com/tags/索引/"}]},{"title":"PHP面试知识梳理","slug":"PHP面试知识梳理","date":"2018-03-31T09:55:04.000Z","updated":"2018-04-03T08:54:26.225Z","comments":true,"path":"2018/03/31/PHP面试知识梳理/","link":"","permalink":"http://marvin9002.github.com/2018/03/31/PHP面试知识梳理/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"http://marvin9002.github.com/categories/后端/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://marvin9002.github.com/tags/面试/"},{"name":"PHP","slug":"PHP","permalink":"http://marvin9002.github.com/tags/PHP/"},{"name":"算法","slug":"算法","permalink":"http://marvin9002.github.com/tags/算法/"},{"name":"网络","slug":"网络","permalink":"http://marvin9002.github.com/tags/网络/"},{"name":"设计模式","slug":"设计模式","permalink":"http://marvin9002.github.com/tags/设计模式/"}]},{"title":"python +splinter自动刷新抢票","slug":"python-splinter自动刷新抢票","date":"2018-03-31T09:48:09.000Z","updated":"2018-03-31T09:53:13.985Z","comments":true,"path":"2018/03/31/python-splinter自动刷新抢票/","link":"","permalink":"http://marvin9002.github.com/2018/03/31/python-splinter自动刷新抢票/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"http://marvin9002.github.com/categories/后端/"}],"tags":[{"name":"python","slug":"python","permalink":"http://marvin9002.github.com/tags/python/"},{"name":"splinter","slug":"splinter","permalink":"http://marvin9002.github.com/tags/splinter/"},{"name":"火车票","slug":"火车票","permalink":"http://marvin9002.github.com/tags/火车票/"}]},{"title":"PHP高效导出Excel(CSV)","slug":"PHP高效导出Excel-CSV","date":"2018-03-31T09:04:05.000Z","updated":"2018-03-31T10:14:58.890Z","comments":true,"path":"2018/03/31/PHP高效导出Excel-CSV/","link":"","permalink":"http://marvin9002.github.com/2018/03/31/PHP高效导出Excel-CSV/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"http://marvin9002.github.com/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://marvin9002.github.com/tags/PHP/"},{"name":"CSV","slug":"CSV","permalink":"http://marvin9002.github.com/tags/CSV/"}]}]}